FUNCTION_BLOCK "AI_Proc"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      AI : Int;   // 通道输入值, 一般定义一个INT类型的符号
      AI_zero : Int := #S7_ZERO;   // 通道零点值（4mA对应数值）
      AI_span : Int := #S7_SPAN;   // 通道量程值（20mA对应数值）
      overflow_SP : Int := 28000;   // 上溢出设置值
      underflow_SP : Int := -500;   // 下溢出设置值
      zero : Real;   // 零点值
      span : Real := 100.0;   // 量程值
      invalid_value : Real := -1000000.0;   // 无效输入时指定输出值
      AH : Real := 80.0;   // 高高报设定值
      WH : Real := 70.0;   // 高报设定值
      WL : Real := 2.0;   // 低报设定值
      AL : Real := 1.0;   // 低低报设定值
      dead_zone : Real := 0.5;   // 死区（赋值0.0时无死区）
      FT_time : Time := T#0MS;   // 容错时间 (单位毫秒 赋值T#0MS时无容错时间)
   END_VAR

   VAR_OUTPUT 
      PV : Real;   // 采集量工程单位数值
      AH_flag : Bool;   // 高高报标志
      WH_flag : Bool;   // 高报标志
      WL_flag : Bool;   // 低报标志
      AL_flag : Bool;   // 低低报标志
      invalid : Bool;   // 数据无效，即 AI_error OR high_overflow OR low_overflow
      AI_error : Bool;   // 非测量输入，比如断线
      overflow : Bool;   // 高溢出
      underflow : Bool;   // 低溢出
      SP_error : Bool;   // 错误
   END_VAR

   VAR 
      trigger_alarm_high { ExternalVisible := 'False'} : Bool;   // 触发高高报
      trigger_warn_high { ExternalVisible := 'False'} : Bool;   // 触发高报
      trigger_warn_low { ExternalVisible := 'False'} : Bool;   // 触发低报
      trigger_alarm_low { ExternalVisible := 'False'} : Bool;   // 触发低低报
      alarm_high_set {InstructionName := 'TON'; LibVersion := '1.0'; ExternalVisible := 'False'} : TON;
      alarm_high_reset {InstructionName := 'TOF'; LibVersion := '1.0'; ExternalVisible := 'False'} : TOF;
      warn_high_set {InstructionName := 'TON'; LibVersion := '1.0'; ExternalVisible := 'False'} : TON;
      warn_high_reset {InstructionName := 'TOF'; LibVersion := '1.0'; ExternalVisible := 'False'} : TOF;
      warn_low_set {InstructionName := 'TON'; LibVersion := '1.0'; ExternalVisible := 'False'} : TON;
      warn_low_reset {InstructionName := 'TOF'; LibVersion := '1.0'; ExternalVisible := 'False'} : TOF;
      alarm_low_set {InstructionName := 'TON'; LibVersion := '1.0'; ExternalVisible := 'False'} : TON;
      alarm_low_reset {InstructionName := 'TOF'; LibVersion := '1.0'; ExternalVisible := 'False'} : TOF;
   END_VAR

   VAR_TEMP 
      value : Real;
      ERR : Bool;
      OVFL : Bool;
      UDFL : Bool;
   END_VAR

   VAR CONSTANT 
      S7_ZERO : Int;   // AI模块零点值
      S7_SPAN : Int := 27648;   // AI模块量程值
      S7_AI_MIN : Int := 32767;   // AI模块最小值
      S7_AI_MAX : Int := -32768;   // AI模块最大值
   END_VAR


BEGIN
	//判断输入值的有效性
	IF #AI = #S7_AI_MIN OR #AI = #S7_AI_MAX THEN
	    // 非测量输入
	    #ERR := TRUE; // 输出
	    #OVFL := FALSE;
	    #UDFL := FALSE;
	ELSIF #AI > #overflow_SP THEN
	    // 高溢出
	    #ERR := FALSE;
	    #OVFL := TRUE; // 输出
	    #UDFL := FALSE;
	ELSIF #AI < #underflow_SP THEN
	    // 低溢出
	    #ERR := FALSE;
	    #UDFL := TRUE; // 输出
	    #OVFL := FALSE;
	ELSE
	    //正常输入
	    #ERR := FALSE;
	    #OVFL := FALSE;
	    #UDFL := FALSE;
	END_IF;
	
	// 设置输出值
	#AI_error := #ERR;
	#overflow := #OVFL;
	#underflow := #UDFL;
	#invalid := #ERR OR #OVFL OR #UDFL;
	IF #invalid THEN
	    #AH_flag := 
	    #WH_flag := 
	    #WL_flag := 
	    #AL_flag := FALSE;
	    #PV := // 无效时不计算，直接赋值为 -1000000.0
	    #value := #invalid_value;
	ELSE
	    #PV := #value := (#AI - #AI_zero) * (#span - #zero) / (#AI_span - #AI_zero) + #zero;
	END_IF;
	
	//参数设置错误
	#SP_error := (#WH > #AH) OR (#WL > #WH) OR (#AL > #WL);
	
	//报警触发
	IF #SP_error OR #invalid THEN
	    #trigger_alarm_high := FALSE;
	    #trigger_warn_high := FALSE;
	    #trigger_warn_low := FALSE;
	    #trigger_alarm_low := FALSE;
	ELSE
	    //上上限报警
	    IF #value > #AH THEN
	        #trigger_alarm_high := TRUE;
	        #trigger_warn_high := FALSE;
	        #trigger_alarm_low := FALSE;
	        #trigger_warn_low := FALSE;
	    END_IF;
	    //上上限报警恢复
	    IF #value < (#AH - #dead_zone) THEN
	        #trigger_alarm_high := FALSE;
	    END_IF;
	    
	    //上限报警
	    IF NOT #trigger_alarm_high AND (#value > #WH) THEN
	        #trigger_warn_high := TRUE;
	        #trigger_alarm_low := FALSE;
	        #trigger_warn_low := FALSE;
	    END_IF;
	    //上限报警恢复
	    IF #value < (#WH - #dead_zone) THEN
	        #trigger_warn_high := FALSE;
	    END_IF;
	    
	    //下下限报警
	    IF (#value < #AL) THEN
	        #trigger_alarm_low := TRUE;
	        #trigger_warn_low := FALSE;
	        #trigger_warn_high := FALSE;
	        #trigger_alarm_high := FALSE;
	    END_IF;
	    //下下限报警恢复
	    IF #value > (#AL + #dead_zone) THEN
	        #trigger_alarm_low := FALSE;
	    END_IF;
	    
	    //下限报警
	    IF NOT #trigger_alarm_low AND (#value < #WL) THEN
	        #trigger_warn_low := TRUE;
	        #trigger_warn_high := FALSE;
	        #trigger_alarm_high := FALSE;
	    END_IF;
	    //下限报警恢复
	    IF #value > (#WL + #dead_zone) THEN
	        #trigger_warn_low := FALSE;
	    END_IF;
	END_IF;
	
	// 容错时限后输出报警标志
	IF #FT_time = T#0ms THEN
	    #AH_flag := #trigger_alarm_high;
	    #WH_flag := #trigger_warn_high;
	    #WL_flag := #trigger_warn_low;
	    #AL_flag := #trigger_alarm_low;
	ELSE
	    // 延时置位高高报
	    #alarm_high_set(
	        IN := #trigger_alarm_high,
	        PT := #FT_time);
	    IF #alarm_high_set.Q THEN
	        #AH_flag := TRUE;
	    END_IF;
	
	    // 延时复位高高报
	    #alarm_high_reset(
	        IN := #trigger_alarm_high,
	        PT := #FT_time);
	    IF NOT #alarm_high_reset.Q THEN
	        #AH_flag := FALSE;
	    END_IF;
	    
	    // 延时置位高报
	    #warn_high_set(
	        IN := #trigger_warn_high,
	        PT := #FT_time);
	    IF #warn_high_set.Q THEN
	        #WH_flag := TRUE;
	    END_IF;
	
	    // 延时复位高报
	    #warn_high_reset(
	        IN := #trigger_warn_high,
	        PT := #FT_time);
	    IF NOT #warn_high_reset.Q THEN
	        #WH_flag := FALSE;
	    END_IF;
	    
	    // 延时置位低报
	    #warn_low_set(
	        IN := #trigger_warn_low,
	        PT := #FT_time);
	    IF #warn_low_set.Q THEN
	        #WL_flag := TRUE;
	    END_IF;
	
	    // 延时复位低报
	    #warn_low_reset(
	        IN := #trigger_warn_low,
	        PT := #FT_time);
	    IF NOT #warn_low_reset.Q THEN
	        #WL_flag := FALSE;
	    END_IF;
	
	    // 延时置位低低报
	    #alarm_low_set(
	        IN := #trigger_alarm_low,
	        PT := #FT_time);
	    IF #alarm_low_set.Q THEN
	        #AL_flag := TRUE;
	    END_IF;
	    
	    // 延时复位低低报
	    #alarm_low_reset(
	        IN := #trigger_alarm_low,
	        PT := #FT_time);
	    IF NOT #alarm_low_reset.Q THEN
	        #AL_flag := FALSE;
	    END_IF;
	    
	END_IF;
	
	    
END_FUNCTION_BLOCK

