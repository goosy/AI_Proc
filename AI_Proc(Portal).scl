FUNCTION_BLOCK "AI_Proc"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.3
KNOW_HOW_PROTECT
AUTHOR:Goosy
NAME:AI_Proc
FAMILY:GooLib

VAR CONSTANT 
    S7_ZERO := 0;
    S7_SPAN := 27648;
    S7_AI_MIN := -32768;
    S7_AI_MIN_WORD := W#16#8000;
    S7_AI_MAX := 32767;
    S7_AI_MAX_WORD := W#16#7FFF;
END_VAR

VAR_INPUT 
    AI : Word; // 通道输入值
    PV_raw AT AI : Int; // 过程值原始值
    zero_raw : Int := #S7_ZERO; // 通道零点值（4mA对应数值）
    span_raw : Int := #S7_SPAN; // 通道量程值（20mA对应数值）
    overflow_SP : Int := 28000; // 上溢出设置值
    underflow_SP : Int := -500; // 下溢出设置值
    zero : Real; // 零点值
    span : Real := 100.0; // 量程值
    invalid_value : Real := -1000000.0; // 无效输入时指定输出值
    AH_limit : Real := 100.0; // 高高报设定值
    WH_limit : Real := 100.0; // 高报设定值
    WL_limit : Real := 0.0; // 低报设定值
    AL_limit : Real := 0.0; // 低低报设定值
    dead_zone : Real := 0.5; // 死区（赋值0.0时无死区）
    FT_time : Time := 0; // 容错时间 (单位毫秒 赋值0时无容错时间)
    ftTime AT FT_time : TIME;
END_VAR

VAR_OUTPUT 
    PV : Real; // 采集量工程单位数值
    AH_flag : Bool; // 高高报标志
    WH_flag : Bool; // 高报标志
    WL_flag : Bool; // 低报标志
    AL_flag : Bool; // 低低报标志
    invalid : Bool; // 数据无效，即 AI_error OR high_overflow OR low_overflow
    AI_error : Bool; // 非测量输入，比如断线
    overflow : Bool; // 高溢出
    underflow : Bool; // 低溢出
    SP_error : Bool; // 错误
END_VAR

VAR 
    trigger_AH { ExternalVisible := 'False'} : Bool; // 触发高高报
    trigger_WH { ExternalVisible := 'False'} : Bool; // 触发高报
    trigger_WL { ExternalVisible := 'False'} : Bool; // 触发低报
    trigger_AL { ExternalVisible := 'False'} : Bool; // 触发低低报
    AH_flag_set {InstructionName := 'TON'; LibVersion := '1.0'; ExternalVisible := 'False'} : TON;
    AH_flag_reset {InstructionName := 'TOF'; LibVersion := '1.0'; ExternalVisible := 'False'} : TOF;
    WH_flag_set {InstructionName := 'TON'; LibVersion := '1.0'; ExternalVisible := 'False'} : TON;
    WH_flag_reset {InstructionName := 'TOF'; LibVersion := '1.0'; ExternalVisible := 'False'} : TOF;
    WL_flag_set {InstructionName := 'TON'; LibVersion := '1.0'; ExternalVisible := 'False'} : TON;
    WL_flag_reset {InstructionName := 'TOF'; LibVersion := '1.0'; ExternalVisible := 'False'} : TOF;
    AL_flag_set {InstructionName := 'TON'; LibVersion := '1.0'; ExternalVisible := 'False'} : TON;
    AL_flag_reset {InstructionName := 'TOF'; LibVersion := '1.0'; ExternalVisible := 'False'} : TOF;
END_VAR

VAR_TEMP 
    value : Real;
    ERR : Bool;
    OVFL : Bool;
    UDFL : Bool;
END_VAR


BEGIN
    //判断输入值的有效性
    IF #PV_raw = #S7_AI_MIN OR #PV_raw = #S7_AI_MAX THEN
         // 非测量输入
         #ERR := TRUE; // 输出
         #OVFL := FALSE;
         #UDFL := FALSE;
    ELSIF #PV_raw > #overflow_SP THEN
         // 高溢出
         #ERR := FALSE;
         #OVFL := TRUE; // 输出
         #UDFL := FALSE;
    ELSIF #PV_raw < #underflow_SP THEN
         // 低溢出
         #ERR := FALSE;
         #UDFL := TRUE; // 输出
         #OVFL := FALSE;
    ELSE
         //正常输入
         #ERR := FALSE;
         #OVFL := FALSE;
         #UDFL := FALSE;
    END_IF;
    
    // 设置输出值
    #AI_error := #ERR;
    #overflow := #OVFL;
    #underflow := #UDFL;
    #invalid := #ERR OR #OVFL OR #UDFL;
    IF #invalid THEN
         #AH_flag := 
         #WH_flag := 
         #WL_flag := 
         #AL_flag := FALSE;
         #PV := // 无效时不计算，直接赋值为 -1000000.0
         #value := #invalid_value;
    ELSE
         #PV := #value := (#PV_raw - #zero_raw) * (#span - #zero) / (#span_raw - #zero_raw) + #zero;
    END_IF;
    
    //参数设置错误
    #SP_error := (#WH_limit > #AH_limit) OR (#WL_limit > #WH_limit) OR (#AL_limit > #WL_limit);
    
    //报警触发
    IF #SP_error OR #invalid THEN
         #trigger_AH := FALSE;
         #trigger_WH := FALSE;
         #trigger_WL := FALSE;
         #trigger_AL := FALSE;
    ELSE
         //上上限报警
         IF #value > #AH_limit THEN
              #trigger_AH := TRUE;
              #trigger_WH := FALSE;
              #trigger_AL := FALSE;
              #trigger_WL := FALSE;
         END_IF;
         //上上限报警恢复
         IF #value < (#AH_limit - #dead_zone) THEN
              #trigger_AH := FALSE;
         END_IF;
         
         //上限报警
         IF NOT #trigger_AH AND (#value > #WH_limit) THEN
              #trigger_WH := TRUE;
              #trigger_AL := FALSE;
              #trigger_WL := FALSE;
         END_IF;
         //上限报警恢复
         IF #value < (#WH_limit - #dead_zone) THEN
              #trigger_WH := FALSE;
         END_IF;
         
         //下下限报警
         IF (#value < #AL_limit) THEN
              #trigger_AL := TRUE;
              #trigger_WL := FALSE;
              #trigger_WH := FALSE;
              #trigger_AH := FALSE;
         END_IF;
         //下下限报警恢复
         IF #value > (#AL_limit + #dead_zone) THEN
              #trigger_AL := FALSE;
         END_IF;
         
         //下限报警
         IF NOT #trigger_AL AND (#value < #WL_limit) THEN
              #trigger_WL := TRUE;
              #trigger_WH := FALSE;
              #trigger_AH := FALSE;
         END_IF;
         //下限报警恢复
         IF #value > (#WL_limit + #dead_zone) THEN
              #trigger_WL := FALSE;
         END_IF;
    END_IF;
    
    // 容错时限后输出报警标志
    IF #ftTime = T#0ms THEN
         #AH_flag := #trigger_AH;
         #WH_flag := #trigger_WH;
         #WL_flag := #trigger_WL;
         #AL_flag := #trigger_AL;
    ELSE
         // 延时置位高高报
         #AH_flag_set(
              IN := #trigger_AH,
              PT := #ftTime);
         IF #AH_flag_set.Q THEN
              #AH_flag := TRUE;
         END_IF;
    
         // 延时复位高高报
         #AH_flag_reset(
              IN := #trigger_AH,
              PT := #ftTime);
         IF NOT #AH_flag_reset.Q THEN
              #AH_flag := FALSE;
         END_IF;
         
         // 延时置位高报
         #WH_flag_set(
              IN := #trigger_WH,
              PT := #ftTime);
         IF #WH_flag_set.Q THEN
              #WH_flag := TRUE;
         END_IF;
    
         // 延时复位高报
         #WH_flag_reset(
              IN := #trigger_WH,
              PT := #ftTime);
         IF NOT #WH_flag_reset.Q THEN
              #WH_flag := FALSE;
         END_IF;
         
         // 延时置位低报
         #WL_flag_set(
              IN := #trigger_WL,
              PT := #ftTime);
         IF #WL_flag_set.Q THEN
              #WL_flag := TRUE;
         END_IF;
    
         // 延时复位低报
         #WL_flag_reset(
              IN := #trigger_WL,
              PT := #ftTime);
         IF NOT #WL_flag_reset.Q THEN
              #WL_flag := FALSE;
         END_IF;
    
         // 延时置位低低报
         #AL_flag_set(
              IN := #trigger_AL,
              PT := #ftTime);
         IF #AL_flag_set.Q THEN
              #AL_flag := TRUE;
         END_IF;
         
         // 延时复位低低报
         #AL_flag_reset(
              IN := #trigger_AL,
              PT := #ftTime);
         IF NOT #AL_flag_reset.Q THEN
              #AL_flag := FALSE;
         END_IF;
         
    END_IF;
    
         
END_FUNCTION_BLOCK

