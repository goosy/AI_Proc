FUNCTION_BLOCK "AI_Proc"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      AI : Int;   // 通道输入值, 一般定义一个INT类型的符号
      zero_raw : Int := #S7_ZERO;   // 通道零点值（4mA对应数值）
      span_raw : Int := #S7_SPAN;   // 通道量程值（20mA对应数值）
      overflow_SP : Int := 28000;   // 上溢出设置值
      underflow_SP : Int := -500;   // 下溢出设置值
      zero : Real;   // 零点值
      span : Real := 100.0;   // 量程值
      invalid_value : Real := -1000000.0;   // 无效输入时指定输出值
      AH_limit : Real := 80.0;   // 高高报设定值
      WH_limit : Real := 70.0;   // 高报设定值
      WL_limit : Real := 2.0;   // 低报设定值
      AL_limit : Real := 1.0;   // 低低报设定值
      dead_zone : Real := 0.5;   // 死区（赋值0.0时无死区）
      FT_time : Time := T#0MS;   // 容错时间 (单位毫秒 赋值T#0MS时无容错时间)
   END_VAR

   VAR_OUTPUT 
      PV : Real;   // 采集量工程单位数值
      AH_flag : Bool;   // 高高报标志
      WH_flag : Bool;   // 高报标志
      WL_flag : Bool;   // 低报标志
      AL_flag : Bool;   // 低低报标志
      invalid : Bool;   // 数据无效，即 AI_error OR high_overflow OR low_overflow
      AI_error : Bool;   // 非测量输入，比如断线
      overflow : Bool;   // 高溢出
      underflow : Bool;   // 低溢出
      SP_error : Bool;   // 错误
   END_VAR

   VAR 
      trigger_AH { ExternalVisible := 'False'} : Bool;   // 触发高高报
      trigger_WH { ExternalVisible := 'False'} : Bool;   // 触发高报
      trigger_WL { ExternalVisible := 'False'} : Bool;   // 触发低报
      trigger_AL { ExternalVisible := 'False'} : Bool;   // 触发低低报
      AH_flag_set {InstructionName := 'TON'; LibVersion := '1.0'; ExternalVisible := 'False'} : TON;
      AH_flag_reset {InstructionName := 'TOF'; LibVersion := '1.0'; ExternalVisible := 'False'} : TOF;
      WH_flag_set {InstructionName := 'TON'; LibVersion := '1.0'; ExternalVisible := 'False'} : TON;
      WH_flag_reset {InstructionName := 'TOF'; LibVersion := '1.0'; ExternalVisible := 'False'} : TOF;
      WL_flag_set {InstructionName := 'TON'; LibVersion := '1.0'; ExternalVisible := 'False'} : TON;
      WL_flag_reset {InstructionName := 'TOF'; LibVersion := '1.0'; ExternalVisible := 'False'} : TOF;
      AL_flag_set {InstructionName := 'TON'; LibVersion := '1.0'; ExternalVisible := 'False'} : TON;
      AL_flag_reset {InstructionName := 'TOF'; LibVersion := '1.0'; ExternalVisible := 'False'} : TOF;
   END_VAR

   VAR_TEMP 
      value : Real;
      ERR : Bool;
      OVFL : Bool;
      UDFL : Bool;
   END_VAR

   VAR CONSTANT 
      S7_ZERO : Int;   // AI模块零点值
      S7_SPAN : Int := 27648;   // AI模块量程值
      S7_AI_MIN : Int := 32767;   // AI模块最小值
      S7_AI_MAX : Int := -32768;   // AI模块最大值
   END_VAR


BEGIN
	//判断输入值的有效性
	IF #AI = #S7_AI_MIN OR #AI = #S7_AI_MAX THEN
	    // 非测量输入
	    #ERR := TRUE; // 输出
	    #OVFL := FALSE;
	    #UDFL := FALSE;
	ELSIF #AI > #overflow_SP THEN
	    // 高溢出
	    #ERR := FALSE;
	    #OVFL := TRUE; // 输出
	    #UDFL := FALSE;
	ELSIF #AI < #underflow_SP THEN
	    // 低溢出
	    #ERR := FALSE;
	    #UDFL := TRUE; // 输出
	    #OVFL := FALSE;
	ELSE
	    //正常输入
	    #ERR := FALSE;
	    #OVFL := FALSE;
	    #UDFL := FALSE;
	END_IF;
	
	// 设置输出值
	#AI_error := #ERR;
	#overflow := #OVFL;
	#underflow := #UDFL;
	#invalid := #ERR OR #OVFL OR #UDFL;
	IF #invalid THEN
	    #AH_flag := 
	    #WH_flag := 
	    #WL_flag := 
	    #AL_flag := FALSE;
	    #PV := // 无效时不计算，直接赋值为 -1000000.0
	    #value := #invalid_value;
	ELSE
	    #PV := #value := (#AI - #zero_raw) * (#span - #zero) / (#span_raw - #zero_raw) + #zero;
	END_IF;
	
	//参数设置错误
	#SP_error := (#WH_limit > #AH_limit) OR (#WL_limit > #WH_limit) OR (#AL_limit > #WL_limit);
	
	//报警触发
	IF #SP_error OR #invalid THEN
	    #trigger_AH := FALSE;
	    #trigger_WH := FALSE;
	    #trigger_WL := FALSE;
	    #trigger_AL := FALSE;
	ELSE
	    //上上限报警
	    IF #value > #AH_limit THEN
	        #trigger_AH := TRUE;
	        #trigger_WH := FALSE;
	        #trigger_AL := FALSE;
	        #trigger_WL := FALSE;
	    END_IF;
	    //上上限报警恢复
	    IF #value < (#AH_limit - #dead_zone) THEN
	        #trigger_AH := FALSE;
	    END_IF;
	    
	    //上限报警
	    IF NOT #trigger_AH AND (#value > #WH_limit) THEN
	        #trigger_WH := TRUE;
	        #trigger_AL := FALSE;
	        #trigger_WL := FALSE;
	    END_IF;
	    //上限报警恢复
	    IF #value < (#WH_limit - #dead_zone) THEN
	        #trigger_WH := FALSE;
	    END_IF;
	    
	    //下下限报警
	    IF (#value < #AL_limit) THEN
	        #trigger_AL := TRUE;
	        #trigger_WL := FALSE;
	        #trigger_WH := FALSE;
	        #trigger_AH := FALSE;
	    END_IF;
	    //下下限报警恢复
	    IF #value > (#AL_limit + #dead_zone) THEN
	        #trigger_AL := FALSE;
	    END_IF;
	    
	    //下限报警
	    IF NOT #trigger_AL AND (#value < #WL_limit) THEN
	        #trigger_WL := TRUE;
	        #trigger_WH := FALSE;
	        #trigger_AH := FALSE;
	    END_IF;
	    //下限报警恢复
	    IF #value > (#WL_limit + #dead_zone) THEN
	        #trigger_WL := FALSE;
	    END_IF;
	END_IF;
	
	// 容错时限后输出报警标志
	IF #FT_time = T#0ms THEN
	    #AH_flag := #trigger_AH;
	    #WH_flag := #trigger_WH;
	    #WL_flag := #trigger_WL;
	    #AL_flag := #trigger_AL;
	ELSE
	    // 延时置位高高报
	    #AH_flag_set(
	        IN := #trigger_AH,
	        PT := #FT_time);
	    IF #AH_flag_set.Q THEN
	        #AH_flag := TRUE;
	    END_IF;
	
	    // 延时复位高高报
	    #AH_flag_reset(
	        IN := #trigger_AH,
	        PT := #FT_time);
	    IF NOT #AH_flag_reset.Q THEN
	        #AH_flag := FALSE;
	    END_IF;
	    
	    // 延时置位高报
	    #WH_flag_set(
	        IN := #trigger_WH,
	        PT := #FT_time);
	    IF #WH_flag_set.Q THEN
	        #WH_flag := TRUE;
	    END_IF;
	
	    // 延时复位高报
	    #WH_flag_reset(
	        IN := #trigger_WH,
	        PT := #FT_time);
	    IF NOT #WH_flag_reset.Q THEN
	        #WH_flag := FALSE;
	    END_IF;
	    
	    // 延时置位低报
	    #WL_flag_set(
	        IN := #trigger_WL,
	        PT := #FT_time);
	    IF #WL_flag_set.Q THEN
	        #WL_flag := TRUE;
	    END_IF;
	
	    // 延时复位低报
	    #WL_flag_reset(
	        IN := #trigger_WL,
	        PT := #FT_time);
	    IF NOT #WL_flag_reset.Q THEN
	        #WL_flag := FALSE;
	    END_IF;
	
	    // 延时置位低低报
	    #AL_flag_set(
	        IN := #trigger_AL,
	        PT := #FT_time);
	    IF #AL_flag_set.Q THEN
	        #AL_flag := TRUE;
	    END_IF;
	    
	    // 延时复位低低报
	    #AL_flag_reset(
	        IN := #trigger_AL,
	        PT := #FT_time);
	    IF NOT #AL_flag_reset.Q THEN
	        #AL_flag := FALSE;
	    END_IF;
	    
	END_IF;
	
	    
END_FUNCTION_BLOCK

